%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <iostream>
   #include <map>
   #include <string>
   #include <vector>
   #include <assert.h>
   #include "utils.hpp"
   using namespace std;
   extern int yylineno;

   string relop(Expression a, Expression b);
   string log_eq(Expression a, Expression b);
   string binop(Expression a, Expression b);
   void check_bool_exp(Expression exp);

   map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent);
   void pop_tables();
   void pop_offsets();
   void push_tables(map<string,pair<string, int>>* table);
   void push_offsets(int offset);
   map<string,pair<string, int>> &top_tables();
   int &top_offsets();
   void insert(string name, string type,int offset, bool is_offset=true);

   const string TYPE_INT    = "int";
   const string TYPE_BOOL   = "bool";
   const string TYPE_BYTE   = "byte";
   const string TYPE_STRING = "string";
  
   int yylex();
   void yyerror(const char*);

   stack<map<string,pair<string, int>>>* tables = NULL;
   stack<int>* offsets = NULL;

   map<string,pair<string, int>>* t = NULL;


   // Gets a string and 
   vector<string> split_str(string str, string delimiter){
      vector<string> tokens;
      size_t position = 0;
      while ((position = str.find(delimiter)) != string::npos) {
         tokens.push_back(str.substr(0, position));
         str.erase(0,position + delimiter.length());
      }
      if(tokens.size()!=0 || !str.empty()){
         tokens.push_back(str);
      }
      return tokens;
   }

   string get_id_type(const string name, const stack<map<string, pair<string, int>>> &tables){
      stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
      while (!tabels_clone->empty()) {
         auto table = tabels_clone->top();
         tabels_clone->pop();
         auto it= table.find(name);
         if (it != table.end()) {
               // if reached here, that means the key already is in some table
               string id_type = it->second.first;
               delete tabels_clone;
               return id_type;
         }
      }
      delete tabels_clone;
      output::errorUndef(yylineno, name);
      exit(0);
   }

   bool name_exists_in_table(const string name,const stack<map<string, pair<string, int>>> &tables, bool is_fun=false){
      /*
      * this function will get a pointer to a string representing a name and a stack of tables
      * the function will return true if the name is already in the tables and false otherwise
      */
      stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
      while (!tabels_clone->empty()) {
         auto table = tabels_clone->top();
         tabels_clone->pop();
         // in c++11 table.contains doesnt exist yet, so to find if the key
         // exists in the table, we search an iterator, and if we got to the end
         // of the table, that means the value is not there
         auto it= table.find(name);
         if (it != table.end()) {
               // if reached here, that means the key already is in some table
               if(is_fun){
                  string id_type = it->second.first;
                  if(id_type.find("->") == string::npos){
                     return false;
                  }
               }
               // if reached here, that means the key already is in some table
               delete tabels_clone;
               return true;
         }
      }
      delete tabels_clone;
      return false;
   }

   string assign_check()

   string gen_fun_type(const string ret_type, const string arguments){
      string func_type="";
      (func_type.append(arguments)).append("->").append(ret_type);
      return func_type;
   }

   template<class input_class, class output_class>
   void print_stack_of_maps(stack<map<input_class, output_class>> s) {
      cout << "\n\n~~~~ Printing Stack" << endl;
      stack<map<input_class, output_class>> *clone = new stack<map<input_class, output_class>>(s);
      int scope_number = 0;
      while (!clone->empty()) {
         map<input_class, output_class> m = clone->top();
         clone->pop();
         cout << "Scope number: " << scope_number++ << endl;
         cout << "[";
         for (const auto elem : m) {
            cout << "name: " << elem.first << ", type: " << elem.second.first << ", offset: " << elem.second.second
                 << endl;
         }
         cout << "]" << endl;
      }
      delete (clone);
   }
%}

%nonassoc VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left EQUALITY_RELOP   
%nonassoc RELATIONAL_RELOP
%left ADD_BINOP 
%left MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc ID      
%nonassoc NUM     
%nonassoc STRING  
%%

Program:       Marker1 Funcs       {
   pop_tables();
   pop_offsets();
}
;
Marker1:       /*epsilon*/       {
      t = make_table(NULL);
      push_tables(t);
      push_offsets(0);

}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      FuncDeclPart1 FuncDeclPart2 {}
;
FuncDeclPart1:  RetType ID LPAREN Formals RPAREN{
   //TODO: check if function and var may have the same name.
      if(name_exists_in_table($2->id_name,*tables)){
         output::errorDef(yylineno,$2->id_name);
         exit(0);
      }
      insert($2->id_name,gen_fun_type($1->type, $4->type),0,false);

      t = make_table(&top_tables());
      push_tables(t);
      push_offsets(top_offsets());

      auto id_names = split_str($4->id_name,", ");
      auto types = split_str($4->type,", ");

      assert(id_names.size() == types.size());
      auto it_names = id_names.begin();
      auto it_types = types.begin();
      int offset = 0;
      while (it_names != id_names.end() || it_types != types.end()) {
         insert(*it_names, *it_types, --offset);
         it_names++;
         it_types++;
      } 
}
FuncDeclPart2:  LBRACE Statements RBRACE {
                  pop_tables();
                  pop_offsets();
}
RetType:       Type        {
                  $$ = new Expression();
                  $$->type = $1->type;
}
               | VOID         {
                  $$ = new Expression();
                  $$->type = "void";
}
;
Formals:       /*epsilon*/       {
                  $$->type = "";
                  $$->id_name = "";
}
               | FormalsList        {
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
}
;
FormalsList:   FormalsDecl       {
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
}
               | FormalsDecl COMMA FormalsList        {
                  $$->type= ($1->type).append(", ").append($3->type);
                  $$->id_name= ($1->id_name).append(", ").append($3->id_name);
               }
;
FormalsDecl:   Type ID        {
                  $$->type = $1->type;
                  $$->id_name = $2->id_name;
}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Statement       {
                  check_bool_exp(*$3);
               }
               | IF LPAREN Exp RPAREN Statement ELSE Statement       {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN Statement       {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN Statement ELSE Statement       {
                  check_bool_exp(*$3);
               }
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements RBRACE         {
                  pop_tables();
                  pop_offsets();
               }
               | Type ID SC         {
                  if(name_exists_in_table($2->id_name,*tables)){
                     output::errorDef(yylineno,$2->id_name);
                     exit(0);
                  }
                  insert($2->id_name,$1->type, top_offsets());
                  top_offsets() += 1;
               }
               | Type ID ASSIGN Exp SC       {
                  if(name_exists_in_table($2->id_name,*tables)){
                     output::errorDef(yylineno,$2->id_name);
                     exit(0);
                  }
                  insert($2->id_name,$1->type, top_offsets());
                  top_offsets() += 1;
               }
               | ID ASSIGN Exp SC         {
                  if(!name_exists_in_table($2->id_name,*tables)){
                     output::errorUndef(yylineno,$2->id_name);
                     exit(0);
                  }
               }
               | Call SC         {print_stack_of_maps(*tables);}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {}
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      t = make_table(&top_tables());
      push_tables(t);
      push_offsets(top_offsets());
}
;
Call:          ID LPAREN ExpList RPAREN         {
                     // Check if the function name exists
                     if(!name_exists_in_table($1->id_name, *tables, true)) {
                        output::errorUndefFunc(yylineno, $1->id_name);
                        exit(0);
                     }

                     // Check if given args matching the function args
                     string fun_sign = get_id_type($1->id_name ,*tables);
                     string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                     vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),", ");
                     vector<string> given_args = split_str($3->type,", ");
                     if(function_args != given_args){
                        output::errorPrototypeMismatch(yylineno,$1->id_name,function_args);
                        exit(0);
                     }
                     /* Rule #5 hw's PDF */
                     $$->type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                  }
               | ID LPAREN RPAREN         {
                     // Check if the function name exists
                     if(!name_exists_in_table($1->id_name, *tables, true)) {
                        output::errorUndefFunc(yylineno, $1->id_name);
                        exit(0);
                  }
                  string fun_sign = get_id_type($1->id_name ,*tables);
                  vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),", ");
                  if(function_args.size()){
                     output::errorPrototypeMismatch(yylineno,$1->id_name,function_args);
                  }

                  /* Rule #5 hw's PDF */
                  $$->type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
               }
;
ExpList:       Exp         {
                  $$ = $1;
}
               | Exp COMMA ExpList        {
                  //TODO: pass the value?
                  $$->type = ($1->type).append(", ").append($3->type);
               }
;
Type:          INT            {
                  $$ = new Expression();
                  $$->type = TYPE_INT;
               }
               | BYTE         {
                  $$ = new Expression();
                  $$->type = TYPE_BYTE;
               }
               | BOOL         {
                  $$ = new Expression();
                  $$->type = TYPE_BOOL;
               }
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                     $$->type = binop(*$1, *$3);
                  }
               | Exp MUL_BINOP Exp         {
                     $$->type = binop(*$1, *$3);
                  }
               | ID        {
                  
                  }
               | Call         {
                  $$->type = $1->type;
               }
               | NUM       {
                  $$->type = TYPE_INT;
                  $$->number = $1->number;
               }
               | NUM B       {
                  $$->number = $1->number;  
                  $$->type = TYPE_BYTE;
               }
               | STRING       {
                  // String is an internal type
                  $$->str=$1->str;  
                  $$->type= TYPE_STRING;
               }
               | TRUE         {
                  $$->bool_value=true;
                  $$->type = TYPE_BOOL;
               }
               | FALSE        {
                  $$->bool_value=false;
                  $$->type = TYPE_BOOL;
               }
               | NOT Exp         {}
               | Exp AND Exp        {
                  $$->type = log_eq(*$1, *$3);
               }
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {
                  $$->type = relop(*$1, *$3);
               }
               | Exp RELATIONAL_RELOP Exp         {
                  $$->type = relop(*$1, *$3);
               }

;
%%

/* Rule #8 hw's PDF */
string relop(Expression a, Expression b){
   if ((get_id_type(a.id_name,*tables) != TYPE_INT && get_id_type(a.id_name,*tables) != TYPE_BYTE)
   || (get_id_type(b.id_name,*tables) != TYPE_INT && get_id_type(b.id_name,*tables) != TYPE_BYTE)) {
      // Both must be numbers
      output::errorMismatch(yylineno);
      exit(0);
   }
   return TYPE_BOOL;
}


/* Rule #9 hw's PDF */
string log_eq(Expression a, Expression b){
   if (get_id_type(a.id_name,*tables) != TYPE_BOOL || get_id_type(b.id_name,*tables) != TYPE_BOOL) {
      // Both must be boolean
      output::errorMismatch(yylineno);
      exit(0);
   }
   return TYPE_BOOL;
}

/* Rule #10 hw's PDF */
string binop(Expression a, Expression b){
   if ((get_id_type(a.id_name,*tables) != TYPE_INT && (get_id_type(a.id_name,*tables) != TYPE_INT))
   || (get_id_type(b.id_name,*tables) != TYPE_BYTE && get_id_type(b.id_name,*tables) != TYPE_BYTE)) {
		// We allow: int&int, int&byte, byte&int or byte&byte
		output::errorMismatch(yylineno);
		exit(0);
	}
	if (get_id_type(a.id_name,*tables) == TYPE_INT || get_id_type(b.id_name,*tables) == TYPE_INT) {
      // If there is int, we will return int type
		return TYPE_INT;
	} else {
		return TYPE_BYTE;
	}
}

/* Rule #16 hw's PDF */
void check_bool_exp(Expression exp){
   if(exp.type == ""){
      return;
   }
   if(exp.type.compare(TYPE_BOOL)){
      output::errorMismatch(yylineno);
		exit(0);
   }
}




map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent){
   // <Name, part<Type, Offset>>
   return new map<string,pair<string, int>>();
}
void pop_tables(){
   tables->pop();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(map<string,pair<string, int>>* table){
   tables->push(*table);
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<string,pair<string, int>> &top_tables(){
   return tables->top();
}

int &top_offsets(){
   return offsets->top();
}

void insert(string name, string type,int offset, bool is_offset){
   if (!is_offset){
         offset = -777;
   }
   (tables->top()).insert({
         name,
         pair<string ,int>(type,offset)
   });
}

void yyerror(const char*){
   output::errorSyn(yylineno); 
}

int main(){
   tables = new stack<map<string,pair<string, int>>>();
   offsets = new stack<int>();
   return yyparse();
}



