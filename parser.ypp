%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <iostream>
   #include <map>
   #include <string>
   #include <vector>
   #include <assert.h>
   #include "utils.hpp"
   #include <set>
   #include <algorithm>
   #include <functional>
   #include <queue>
   using namespace std;
   extern int yylineno;

   string relop(Expression a, Expression b);
   string log_eq(Expression a, Expression b);
   string binop(Expression a, Expression b);
   void check_bool_exp(Expression exp);
   bool check_leagal_break();

   void pop_tables();
   void pop_offsets();
   void push_tables();
   void push_offsets(int offset);
   void push_regular_scope();
   void pop_scope();
   void push_while_scope();
   void push_top_scope();
   map<string,pair<string, int>> &top_tables();
   int &top_offsets();
   void insert(string name, string type,int offset, bool is_fun);

   const string TYPE_INT    = "INT";
   const string TYPE_BOOL   = "BOOL";
   const string TYPE_BYTE   = "BYTE";
   const string TYPE_STRING = "STRING";
   const string TYPE_VOID = "VOID";
  
   int yylex();
   void yyerror(const char*);

   const string WHILE_SCOPE = "while_scope";
   const string REGULAR_SCOPE = "regular_scope";

   stack<map<string,pair<string, int>>>* tables = NULL;
   stack<string>* scope_type = NULL;
   stack<queue<string>>* insertion_orders = NULL;
   stack<int>* offsets = NULL;

   map<string,pair<string, int>>* t = NULL;

   bool assign_type_check(string var,string exp) {
      // the string compare function will return 0 (false) only if the string are the same
      if(var.compare(exp)){
         if(var.compare(TYPE_INT) || exp.compare(TYPE_BYTE))  {
            return false;
         }
      }
      return true;
   }


   string vectorToString(const std::vector<string>& argTypes) {
      string res;
      res = "(";
      for(int i = 0; i < argTypes.size(); ++i) {
         res.append(argTypes[i]);
         if (i + 1 < argTypes.size())
            res.append(",");
      }
      res.append(")");
      return res;
   }
   // Gets a string and 
   vector<string> split_str(string str, string delimiter){
      if(str[0] == '('){
         str.erase(0,1);
      }
      if(str[str.length()-1] == ')'){
         str.erase(str.length()-1,1);
      }
      vector<string> tokens;
      size_t position = 0;
      while ((position = str.find(delimiter)) != string::npos) {
         tokens.push_back(str.substr(0, position));
         str.erase(0,position + delimiter.length());
      }
      if(tokens.size()!=0 || !str.empty()){
         tokens.push_back(str);
      }
      return tokens;
   }

   string get_id_type(const string name, const stack<map<string, pair<string, int>>> &tables){
      stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
      while (!tabels_clone->empty()) {
         auto table = tabels_clone->top();
         tabels_clone->pop();
         auto it= table.find(name);
         if (it != table.end()) {
               // if reached here, that means the key already is in some table
               string id_type = it->second.first;
               delete tabels_clone;
               return id_type;
         }
      }
      delete tabels_clone;
      output::errorUndef(yylineno, name);
      exit(0);
   }

   bool name_exists_in_table(const string name,const stack<map<string, pair<string, int>>> &tables, bool is_fun=false){
      /*
      * this function will get a pointer to a string representing a name and a stack of tables
      * the function will return true if the name is already in the tables and false otherwise
      */
      stack<map<string, pair<string, int>>> *tabels_clone = new stack<map<string, pair<string, int>>>(tables);
      while (!tabels_clone->empty()) {
         auto table = tabels_clone->top();
         tabels_clone->pop();
         // in c++11 table.contains doesnt exist yet, so to find if the key
         // exists in the table, we search an iterator, and if we got to the end
         // of the table, that means the value is not there
         auto it= table.find(name);
         if (it != table.end()) {
               // if reached here, that means the key already is in some table
               if(is_fun){
                  string id_type = it->second.first;
                  if(id_type.find("->") == string::npos){
                     return false;
                  }
               }
               // if reached here, that means the key already is in some table
               delete tabels_clone;
               return true;
         }
      }
      delete tabels_clone;
      return false;
   } 

   void print_map_by_order(map<string, pair<string, int>> scope_map,queue<string> orders){
      queue<string>* clone = new queue<string> (orders);
      string name;
      while (clone->size()!= 0){
         name = clone->front();
         clone->pop();
         auto element = scope_map[name];
         output::printID(name, element.second, element.first);
      }
   }

   template<class input_class, class output_class>
   void print_stack_of_maps(stack<map<input_class, output_class>> s) {
      stack<map<input_class, output_class>> *clone = new stack<map<input_class, output_class>>(s);
      while (!clone->empty()) {
         map<input_class, output_class> m = clone->top();
         clone->pop();
         print_map_by_order(m);
      }
      delete (clone);
   }
%}

%nonassoc VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left EQUALITY_RELOP   
%nonassoc RELATIONAL_RELOP
%left ADD_BINOP 
%left MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc ID      
%nonassoc NUM     
%nonassoc STRING  
%%

Program:       Marker1 Funcs       {
   if(!name_exists_in_table("main",*tables,true)){
      output::errorMainMissing();
      exit(0);
   }else{
      string fun_sign = get_id_type("main" ,*tables);
      string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
      string function_args = fun_sign.substr(0,fun_sign.find("->"));
      if(ret_type.compare(TYPE_VOID) || function_args.compare("()")){
         output::errorMainMissing();
         exit(0);
      }
   }
   output::endScope();
   print_map_by_order(tables->top(),insertion_orders->top());
   pop_tables();
   pop_offsets();
}
;
Marker1:       /*epsilon*/       {
      push_tables();
      push_offsets(0);
      vector<string> args_to_print;
      args_to_print.push_back(TYPE_STRING);
      insert("print", output::makeFunctionType(TYPE_VOID, args_to_print),0, true);
      args_to_print.clear();
      args_to_print.push_back(TYPE_INT);
      insert("printi", output::makeFunctionType(TYPE_VOID, args_to_print),0, true);
      push_regular_scope();
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      FuncDeclPart1 FuncDeclPart2 {}
;
FuncDeclPart1:  RetType ID LPAREN Formals RPAREN{      
      auto function_args = split_str($4->type, ",");
      insert($2->id_name,output::makeFunctionType($1->type, function_args),0, true);
      push_tables();
      push_offsets(top_offsets());
      push_regular_scope();

      auto id_names = split_str($4->id_name,",");
      auto types = split_str($4->type,",");

      assert(id_names.size() == types.size());
      auto it_names = id_names.begin();
      auto it_types = types.begin();
      int offset = 0;
      while (it_names != id_names.end() || it_types != types.end()) {
         insert(*it_names, *it_types, --offset, false);
         it_names++;
         it_types++;
      } 
}
FuncDeclPart2:  LBRACE Statements RBRACE Marker3 {}
RetType:       Type        {
                  $$ = new Expression();
                  $$->type = $1->type;
}
               | VOID         {
                  $$ = new Expression();
                  $$->type = TYPE_VOID;
}
;
Formals:       /*epsilon*/       {
                  $$ = new Expression();
                  $$->type = "";
                  $$->id_name = "";
}
               | FormalsList        {
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
}
;
FormalsList:   FormalsDecl       {
                  $$->type = $1->type;
                  $$->id_name = $1->id_name;
}
               | FormalsDecl COMMA FormalsList        {
                  $$->type= ($1->type).append(",").append($3->type);
                  $$->id_name= ($1->id_name).append(",").append($3->id_name);
               }
;
FormalsDecl:   Type ID        {
                  $$->type = $1->type;
                  $$->id_name = $2->id_name;
}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Marker2 Statement Marker3     {
                  check_bool_exp(*$3);
               }
               | IF LPAREN Exp RPAREN Marker2 Statement Marker3 ELSE Marker2 Statement Marker3      {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN marker4 Statement Marker3    {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN marker4 Statement Marker3 ELSE Marker2 Statement Marker3      {
                  check_bool_exp(*$3);
               }
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements Marker3 RBRACE  {}
               | Type ID SC         {
                  insert($2->id_name,$1->type, top_offsets(), false);
                  top_offsets() += 1;
               }
               | Type ID ASSIGN Exp SC       {
                  assign_type_check($1->type, $4->type);
                  insert($2->id_name,$1->type, top_offsets(), false);
                  top_offsets() += 1;
                  // we need to check if the number is not larger then 255
                  //TODO: check what to do with negative numbers ? 
                  if(!TYPE_BYTE.compare($1->type) && $4->number > 255){
                     output::errorByteTooLarge(yylineno,to_string($$->number));
                     exit(0); 
                  }
               }
               | ID ASSIGN Exp SC         {
                  assign_type_check(get_id_type($1->id_name, *tables), $3->type);
                  if(!name_exists_in_table($1->id_name,*tables)){
                     output::errorUndef(yylineno,$1->id_name);
                     exit(0);
                  }
                  // we need to check if the number is not larger then 255
                  // TODO: check what to do with negative numbers ?
                  if(!TYPE_BYTE.compare(get_id_type($1->id_name, *tables)) && $3->number > 255){
                     cout << " i am here 2" << endl;
                     output::errorByteTooLarge(yylineno,to_string($$->number));
                     exit(0);
                  }
               }
               | Call SC         {}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {
                  if(!check_leagal_break()){
                     output::errorUnexpectedBreak(yylineno);
                     exit(0);
                  }
               }
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      // this marker pushes a scope of type regular
      push_tables();
      push_offsets(top_offsets());
      // the reason we use push top scope, is if we are in a while scope, and we open a new scope
      // we can still use break
      // TODO: check this
      // IMPORTANT!!! this mechanizem makes sure that the while break will work at all !
      // because the while opens a new scope and inside it, the statment opens another scope
      // and because the while pushes a while_scope to the scope stack
      // this marker keeps the break leagal inside the while
      push_top_scope();
}
Marker3:       /*epsilon*/        {
      output::endScope();
      print_map_by_order(tables->top(),insertion_orders->top());
      pop_tables();
      pop_offsets();
      pop_scope();
}
marker4:       /*epsilon*/        {
      //this marker pushed a scope of type while
      push_tables();
      push_offsets(top_offsets());
      push_while_scope();
}
;
Call:          ID LPAREN ExpList RPAREN         {
                     // Check if the function name exists
                     if(!name_exists_in_table($1->id_name, *tables, true)) {
                        output::errorUndefFunc(yylineno, $1->id_name);
                        exit(0);
                     }

                     // Check if given args matching the function args
                     string fun_sign = get_id_type($1->id_name ,*tables);
                     string ret_type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                     vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),",");
                     vector<string> given_args = split_str($3->type,",");

                     if(function_args.size() != given_args.size()){
                        output::errorPrototypeMismatch(yylineno,$1->id_name,function_args);
                        exit(0);
                     }
                     for(int i=0; i< function_args.size() || i< given_args.size(); i++){
                        if(function_args[i].compare(given_args[i]) &&
                           (function_args[i].compare(TYPE_INT) || given_args[i].compare(TYPE_BYTE))   )
                           {
                              output::errorPrototypeMismatch(yylineno,$1->id_name,function_args);
                              exit(0);
                           }
                     }

                     /* Rule #5 hw's PDF */
                     $$->type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
                  }
               | ID LPAREN RPAREN         {
                  // Check if the function name exists
                  if(!name_exists_in_table($1->id_name, *tables, true)) {
                     output::errorUndefFunc(yylineno, $1->id_name);
                     exit(0);
                  }
                  string fun_sign = get_id_type($1->id_name ,*tables);
                  vector<string> function_args = split_str(fun_sign.substr(0,fun_sign.find("->")),",");
                  if(!function_args.empty()){
                     output::errorPrototypeMismatch(yylineno,$1->id_name,function_args);
                  }

                  /* Rule #5 hw's PDF */
                  $$->type = fun_sign.substr(fun_sign.find("->")+2, fun_sign.size()-1);
               }
;
ExpList:       Exp         {
                  $$->type = $1->type;
}
               | Exp COMMA ExpList        {
                  //TODO: pass the value?
                  $$->type = ($1->type).append(",").append($3->type);
               }
;
Type:          INT            {
                  $$ = new Expression();
                  $$->type = TYPE_INT;
               }
               | BYTE         {
                  $$ = new Expression();
                  $$->type = TYPE_BYTE;
               }
               | BOOL         {
                  $$ = new Expression();
                  $$->type = TYPE_BOOL;
               }
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                  $$->type = binop(*$1, *$3);
               }
               | Exp MUL_BINOP Exp         {
                  $$->type = binop(*$1, *$3);
               }
               | ID        {
                  $$->type = get_id_type($1->id_name, *tables);
               }
               | Call         {
                  $$->type = $1->type;
               }
               | NUM       {
                  $$->type = TYPE_INT;
                  $$->number = $1->number;
               }
               | NUM B       {
                  $$->number = $1->number;  
                  $$->type = TYPE_BYTE;
               }
               | STRING       {
                  // String is an internal type
                  $$->str=$1->str;  
                  $$->type= TYPE_STRING;
               }
               | TRUE         {
                  $$->bool_value=true;
                  $$->type = TYPE_BOOL;
               }
               | FALSE        {
                  $$->bool_value=false;
                  $$->type = TYPE_BOOL;
               }
               | NOT Exp         {}
               | Exp AND Exp        {
                  $$->type = log_eq(*$1, *$3);
               }
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {
                  $$->type = relop(*$1, *$3);
               }
               | Exp RELATIONAL_RELOP Exp         {
                  $$->type = relop(*$1, *$3);
               }

;
%%

/* Rule #8 hw's PDF */
string relop(Expression a, Expression b){
   if ((get_id_type(a.id_name,*tables) != TYPE_INT && get_id_type(a.id_name,*tables) != TYPE_BYTE)
   || (get_id_type(b.id_name,*tables) != TYPE_INT && get_id_type(b.id_name,*tables) != TYPE_BYTE)) {
      // Both must be numbers
      output::errorMismatch(yylineno);
      exit(0);
   }
   return TYPE_BOOL;
}


/* Rule #9 hw's PDF */
string log_eq(Expression a, Expression b){
   if (get_id_type(a.id_name,*tables) != TYPE_BOOL || get_id_type(b.id_name,*tables) != TYPE_BOOL) {
      // Both must be boolean
      output::errorMismatch(yylineno);
      exit(0);
   }
   return TYPE_BOOL;
}

/* Rule #10 hw's PDF */
string binop(Expression a, Expression b){
   if ((get_id_type(a.id_name,*tables) != TYPE_INT && (get_id_type(a.id_name,*tables) != TYPE_INT))
   || (get_id_type(b.id_name,*tables) != TYPE_BYTE && get_id_type(b.id_name,*tables) != TYPE_BYTE)) {
		// We allow: int&int, int&byte, byte&int or byte&byte
		output::errorMismatch(yylineno);
		exit(0);
	}
	if (get_id_type(a.id_name,*tables) == TYPE_INT || get_id_type(b.id_name,*tables) == TYPE_INT) {
      // If there is int, we will return int type
		return TYPE_INT;
	} else {
		return TYPE_BYTE;
	}
}

/* Rule #16 hw's PDF */
void check_bool_exp(Expression exp){
   if(exp.type == ""){
      return;
   }
   if(exp.type.compare(TYPE_BOOL)){
      output::errorMismatch(yylineno);
		exit(0);
   }
}


void pop_tables(){
   tables->pop();
   insertion_orders->pop();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(){
   tables->push(map<string,pair<string, int>>());
   insertion_orders->push(queue<string>());
   
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<string,pair<string, int>> &top_tables(){
   return tables->top();
}

int &top_offsets(){
   return offsets->top();
}

void insert(string name, string type,int offset, bool is_fun){
   if(name_exists_in_table(name,*tables)){
      output::errorDef(yylineno,name);
      exit(0);
   }
   (tables->top()).insert({
         name,
         pair<string ,int>(type,offset)
   });
   insertion_orders->top().push(name);
}

void yyerror(const char*){
   output::errorSyn(yylineno); 
}

int main(){
   tables = new stack<map<string,pair<string, int>>>();
   offsets = new stack<int>();
   insertion_orders = new stack<queue<string>> ();
   scope_type = new stack<string>();
   return yyparse();
}

void push_regular_scope(){
   scope_type->push(REGULAR_SCOPE);
}
void pop_scope(){
   scope_type->pop();
}
void push_while_scope(){
   scope_type->push(WHILE_SCOPE);
}

void push_top_scope(){
   scope_type->push(scope_type->top());
}

bool check_leagal_break(){
   // current_scope_type.comapre(REGULAR_SCOPE) will be 0 (false) if we are in a regular scope
   // meaning not in a while scope, and so breack is ileagal
   if(scope_type->top().compare(WHILE_SCOPE)){
     return false;
   }
   return true;
}




