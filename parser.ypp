%{
   #include "hw3_output.hpp"
   using namespace std;
   

   int yylex();
   void yyerror(const char*);
   enum Type {INT,BYTE,BOOL,STRING};
   union Value {
      bool bool_value;
      int number;
      char* str;
   };

struct EXP_data{
   Type type;
   Value value;  
};
   
%}


%union{
   Type type;
   EXP_data expression;
   Value value;
   enum {PLUS,MIUNS,MUL,DIVIDE} op;
   // going to contain all the possible types
}

%nonassoc <type> VOID    
%nonassoc <type> INT     
%nonassoc <type> BYTE    
%nonassoc B       
%nonassoc <type> BOOL    
%nonassoc <value> TRUE    
%nonassoc <value> FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left <op> EQUALITY_RELOP   
%nonassoc <op> RELATIONAL_RELOP
%left <op> ADD_BINOP 
%left <op> MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc ID      
%nonassoc <value> NUM     
%nonassoc <value> STRING  


%type <expression> Exp
%%

Program:       Marker1 Funcs       {
   pop(tables);
   pop(offsets);
}
;
Marker1:       /*epsilon*/       {
      t = make_table(null);
      push(t,tables);
      push(0,offsets);
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE         {}
;
RetType:       Type        {}
               | VOID         {}
;
Formals:       /*epsilon*/       {}
               | FormalsList        {}
;
FormalsList:   FormalsDecl       {}
               | FormalsDecl COMMA FormalsList        {}
;
FormalsDecl:   Type ID        {}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Statement       {}
               | IF LPAREN Exp RPAREN Statement ELSE Statement       {}
               | WHILE LPAREN Exp RPAREN Statement       {}
               | WHILE LPAREN Exp RPAREN Statement ELSE Statement       {}
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements RBRACE         {
                  pop(tables);
                  pop(offsets);
               }
               | Type ID SC         {
                  insert(top(tables), ID.name, vartype.type, top(offsets));
                  top(offsets) += vartype.size;
               }
               | Type ID ASSIGN Exp SC       {}
               | ID ASSIGN Exp SC         {}
               | Call SC         {}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {}
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      t = make_table(top(tables));
      push(t,tables);
      push(top(offsets),offsets);
}
;
Call:          ID LPAREN ExpList RPAREN         {}
               | ID LPAREN RPAREN         {}
;
ExpList:       Exp         {}
               | Exp COMMA ExpList        {}
;
Type:          INT         {}
               | BYTE         {}
               | BOOL         {}
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                   }
               | Exp MUL_BINOP Exp         {}
               | ID        {}
               | Call         {}
               | NUM       {$$.value.number = $1;$$.type=Type.INT}
               | NUM B       {$$.value.number = $1;$$.type=Type.BYTE}
               | STRING       {$$.value.str=$1;$$.type=Type.STRING // String is an intenal type
                                                                  // }
               | TRUE         {$$.value.bool_value=true;$$.type=Type.BOOL}
               | FALSE        {$$.value.bool_value=false;$$.type=Type.BOOL}
               | NOT Exp         {}
               | Exp AND Exp        {}
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {}
               | Exp RELATIONAL_RELOP Exp        {}

;

%%

void yyerror(const char*){
   extern int yylineno;
   output::errorSyn(yylineno); 
}

int main(){
  return yyparse();
}
