%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <iostream>
   #include <map>
   #include <string>
   using namespace std;
   map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent);
   void pop_tables();
   void pop_offsets();
   void push_tables(map<string,pair<string, int>>* table);
   void push_offsets(int offset);
   map<string,pair<string, int>> &top_tables();
   int &top_offsets();
   void insert(string name, string type,int offset);

   #define OP_PLUS     "op_plus"
   #define OP_MINUS    "op_minus"
   #define OP_MUL      "op_mul"
   #define OP_DIV      "op_div"

   #define TYPE_INT    "type_int"
   #define TYPE_BOOL   "type_bool"
   #define TYPE_BYTE   "type_byte"
   #define TYPE_STRING "type_string"

   int yylex();
   void yyerror(const char*);

   stack<map<string,pair<string, int>>>* tables = NULL;
   stack<int>* offsets = NULL;

   map<string,pair<string, int>>* t = NULL;
%}

%union{
   struct {
      string* type;
      bool bool_value;
      int number;
      string* str;
   }  expression;  
   bool bool_value;
   int number;
   string* str;
   char* op;
   string* id_name;
   string* type;
   // going to contain all the possible types
};

%nonassoc VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left <op> EQUALITY_RELOP   
%nonassoc <op> RELATIONAL_RELOP
%left <op> ADD_BINOP 
%left <op> MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc <id_name> ID      
%nonassoc <number> NUM     
%nonassoc <str> STRING  


%type <expression> Exp
%type <type> Type

%%

Program:       Marker1 Funcs       {
   pop_tables();
   pop_offsets();
}
;
Marker1:       /*epsilon*/       {
      t = make_table(NULL);
      push_tables(t);
      push_offsets(0);
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE         {}
;
RetType:       Type        {}
               | VOID         {}
;
Formals:       /*epsilon*/       {}
               | FormalsList        {}
;
FormalsList:   FormalsDecl       {}
               | FormalsDecl COMMA FormalsList        {}
;
FormalsDecl:   Type ID        {}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Statement       {}
               | IF LPAREN Exp RPAREN Statement ELSE Statement       {}
               | WHILE LPAREN Exp RPAREN Statement       {}
               | WHILE LPAREN Exp RPAREN Statement ELSE Statement       {}
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements RBRACE         {
                  pop_tables();
                  pop_offsets();
               }
               | Type ID SC         {
                   cout << "Type ID SC     "  << endl;
                  cout << "CHECK    " << *$2 << endl;
                  insert(*$2, *$1, top_offsets());
                  top_offsets() += 1;
               }
               | Type ID ASSIGN Exp SC       {
                  cout << "Type ID ASSIGN Exp SC     " << endl;
                  cout << "CHECK    " << *$2 << endl;

                  insert(*$2, *$1, top_offsets());
                  top_offsets() += 1;
                  cout << " offsets size is: " << offsets->size() << endl;
                  stack<int>* copy = new stack<int>(*offsets);
                  cout << "[";
                  while(!copy->empty())
                  {
                     std::cout << copy->top() << ",";
                     copy->pop(); 
                  }
                  cout << "]" << endl;


                  /* Tables: */
                  cout << "tables size is: " << tables->size() << endl;
                  stack<map<string,pair<string, int>>>* copyT = new stack<map<string,pair<string, int>>>(*tables);
                  cout << "[";
                  while(!copyT->empty())
                  {
                     map<string,pair<string, int>> temp_map = copyT->top();
                     cout << "TEMP MAP  size is: " << temp_map.size() << endl;
                     for(const auto& x : temp_map){
                        std::cout << "Name: " << x.first << ", Type: " << x.second.first <<", Offset: "<< x.second.second <<  endl;
                     }
                     copyT->pop(); 
                  }
                  cout << "]" << endl;

               }
               | ID ASSIGN Exp SC         {}
               | Call SC         {}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {}
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      t = make_table(&top_tables());
      push_tables(t);
      push_offsets(top_offsets());
}
;
Call:          ID LPAREN ExpList RPAREN         {}
               | ID LPAREN RPAREN         {}
;
ExpList:       Exp         {}
               | Exp COMMA ExpList        {}
;
Type:          INT            {
                  $$ = new string(TYPE_INT);
               }
               | BYTE         {
                  $$ = new string(TYPE_BYTE);
               }
               | BOOL         {
                  $$ = new string(TYPE_BOOL);
               }
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                   }
               | Exp MUL_BINOP Exp         {}
               | ID        {cout << "ID" << endl;}
               | Call         {}
               | NUM       {
                  $$.number = $1;  cout << "EXP -> NUM (PARSER): " << $1  << endl;
                  $$.type = new string(TYPE_INT);
                  cout << "after" << endl;
               }
               | NUM B       {
                  $$.number = $1;  cout << "EXP -> NUM B(PARSER): " << $1  << endl;
                  $$.type = new string(TYPE_BYTE);
               }
               | STRING       {
                  // String is an internal type
                  $$.str=$1;  cout << "EXP -> STRING(PARSER): " << *$1  << endl;
                  $$.type = new string(TYPE_STRING);
               }
               | TRUE         {
                  $$.bool_value=true;
                  $$.type = new string(TYPE_BOOL);
               }
               | FALSE        {
                  $$.bool_value=false;
                  $$.type = new string(TYPE_BOOL);
               }
               | NOT Exp         {}
               | Exp AND Exp        {}
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {}
               | Exp RELATIONAL_RELOP Exp        {}

;

%%

map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent){
   // <Name, part<Type, Offset>>
   return new map<string,pair<string, int>>();
}
void pop_tables(){
   tables->pop();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(map<string,pair<string, int>>* table){
   tables->push(*table);
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<string,pair<string, int>> &top_tables(){
   return tables->top();
}

int &top_offsets(){
   return offsets->top();
}

void insert(string name, string type,int offset){
   cout << "INSIDE INSTERT FUNCTION: name: " << name << endl;
   cout << "INSIDE INSTERT FUNCTION: type:" << type << endl;
   cout << "INSIDE INSTERT FUNCTION:  :offset: " << offset << endl;



   (tables->top()).insert({
         name,
         pair<string ,int>(type,offset)
   });
}

void yyerror(const char*){
   extern int yylineno;
   output::errorSyn(yylineno); 
}

int main(){
   tables = new stack<map<string,pair<string, int>>>();
   offsets = new stack<int>();

   return yyparse();
}
