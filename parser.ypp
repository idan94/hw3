%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <map>
   using namespace std;

   map<char*,pair<char*, int>>* make_table(map<char*,pair<char*, int>>* parent);
   void pop_tables();
   void pop_offsets();
   void push_tables(map<char*,pair<char*, int>>* table);
   void push_offsets(int offset);
   map<char*,pair<char*, int>> &top_tables();
   int &top_offsets();
   void insert(map<char*,pair<char*, int>> table, char* name, char* type,int offset);


   int yylex();
   void yyerror(const char*);


   stack<map<char*,pair<char*, int>>>* tables = NULL;
   stack<int>* offsets = NULL;
   map<char*,pair<char*, int>>* t = NULL;
%}

%union{
   struct {
      char* type;
      bool bool_value;
      int number;
      char* str;
   }  expression;  
   bool bool_value;
   int number;
   char* str;
   enum {PLUS,MIUNS,MUL,DIVIDE} op;
   // going to contain all the possible types
};

%nonassoc  VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left <op> EQUALITY_RELOP   
%nonassoc <op> RELATIONAL_RELOP
%left <op> ADD_BINOP 
%left <op> MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc ID      
%nonassoc <number> NUM     
%nonassoc <str> STRING  


%type <expression> Exp
%%

Program:       Marker1 Funcs       {
   pop_tables();
   pop_offsets();
}
;
Marker1:       /*epsilon*/       {
      t = make_table(NULL);
      push_tables(t);
      push_offsets(0);
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE         {}
;
RetType:       Type        {}
               | VOID         {}
;
Formals:       /*epsilon*/       {}
               | FormalsList        {}
;
FormalsList:   FormalsDecl       {}
               | FormalsDecl COMMA FormalsList        {}
;
FormalsDecl:   Type ID        {}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Statement       {}
               | IF LPAREN Exp RPAREN Statement ELSE Statement       {}
               | WHILE LPAREN Exp RPAREN Statement       {}
               | WHILE LPAREN Exp RPAREN Statement ELSE Statement       {}
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements RBRACE         {
                  pop_tables();
                  pop_offsets();
               }
               | Type ID SC         {
                  insert(top_tables(), "ID.name", "vartype.type", top_offsets());
                  top_offsets() += 1;
               }
               | Type ID ASSIGN Exp SC       {}
               | ID ASSIGN Exp SC         {}
               | Call SC         {}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {}
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      t = make_table(&top_tables());
      push_tables(t);
      push_offsets(top_offsets());
}
;
Call:          ID LPAREN ExpList RPAREN         {}
               | ID LPAREN RPAREN         {}
;
ExpList:       Exp         {}
               | Exp COMMA ExpList        {}
;
Type:          INT         {}
               | BYTE         {}
               | BOOL         {}
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                   }
               | Exp MUL_BINOP Exp         {}
               | ID        {}
               | Call         {}
               | NUM       {$$.number = $1;
               $$.type="T_INT";}
               | NUM B       {$$.number = $1;
               $$.type="T_BYTE";}
               | STRING       {$$.str=$1;
               $$.type="T_STRING";
                // String is an intenal type
               }
               | TRUE         {$$.bool_value=true;
               $$.type="T_BOOL";}
               | FALSE        {$$.bool_value=false;
               $$.type="T_BOOL";}
               | NOT Exp         {}
               | Exp AND Exp        {}
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {}
               | Exp RELATIONAL_RELOP Exp        {}

;

%%

map<char*,pair<char*, int>>* make_table(map<char*,pair<char*, int>>* parent){
   // <Name, Type, Offset>
   return new map<char*,pair<char*, int>>();
}
void pop_tables(){
   tables->pop();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(map<char*,pair<char*, int>>* table){
   tables->push(*table);
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<char*,pair<char*, int>> &top_tables(){
   return tables->top();
}

int &top_offsets(){
   return offsets->top();
}

void insert(map<char*,pair<char*, int>> table, char* name, char* type,int offset){
   table.insert(
      pair<
         char*,
         pair<
            char*,int>
      >
      (
         name,
         pair<char*,int>(type,offset)
      )
      );
}

void yyerror(const char*){
   extern int yylineno;
   output::errorSyn(yylineno); 
}

int main(){
   tables = new stack<map<char*,pair<char*, int>>>();
   offsets = new stack<int>();
   return yyparse();
}
