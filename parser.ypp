%{
   #include "hw3_output.hpp"
   #include <stack>
   #include <iostream>
   #include <map>
   #include <string>
   using namespace std;
   extern int yylineno;
   struct Expression{
      const string* type;
      bool bool_value;
      int number;
      string* str;

      Expression() : type{NULL}, bool_value{false}, number{0}, str{NULL} {}
	
   };
   typedef struct Expression Expression;
   string* relop(Expression a, Expression b);
   string* log_eq(Expression a, Expression b);
   string* binop(Expression a, Expression b);
   void check_bool_exp(Expression exp);

   map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent);
   void pop_tables();
   void pop_offsets();
   void push_tables(map<string,pair<string, int>>* table);
   void push_offsets(int offset);
   map<string,pair<string, int>> &top_tables();
   int &top_offsets();
   void insert(string name, string type,int offset);

   const string TYPE_INT    = "int";
   const string TYPE_BOOL   = "bool";
   const string TYPE_BYTE   = "byte";
   const string TYPE_STRING = "string";
  
   int yylex();
   void yyerror(const char*);

   stack<map<string,pair<string, int>>>* tables = NULL;
   stack<int>* offsets = NULL;

   map<string,pair<string, int>>* t = NULL;
%}
%code requires{
   struct Expression;
}
%union{
   Expression* expression;  
   bool bool_value;
   int number;
   string* str;
   string* op;
   string* id_name;
   const string* type;
   // going to contain all the possible types
};

%nonassoc VOID    
%nonassoc INT     
%nonassoc BYTE    
%nonassoc B       
%nonassoc BOOL    
%nonassoc TRUE    
%nonassoc FALSE   
%nonassoc RETURN  
%nonassoc IF      
%nonassoc WHILE   
%nonassoc BREAK   
%nonassoc CONTINUE
%nonassoc SC      
%nonassoc COMMA   
%nonassoc LBRACE  
%nonassoc RBRACE  
%right ASSIGN 
%left OR   
%left AND    
%left <op> EQUALITY_RELOP   
%nonassoc <op> RELATIONAL_RELOP
%left <op> ADD_BINOP 
%left <op> MUL_BINOP  
%right NOT    
%left LPAREN  
%left RPAREN 
%nonassoc ELSE //Take Else Before RPAREN ')'
%nonassoc <id_name> ID      
%nonassoc <number> NUM     
%nonassoc <str> STRING  


%type <expression> Exp
%type <type> Type
%type <type> Call

%%

Program:       Marker1 Funcs       {
   pop_tables();
   pop_offsets();
}
;
Marker1:       /*epsilon*/       {
      t = make_table(NULL);
      push_tables(t);
      push_offsets(0);
}
Funcs:         /*epsilon*/       {}
               | FuncDecl Funcs        {}
;
FuncDecl:      RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE         {}
;
RetType:       Type        {}
               | VOID         {}
;
Formals:       /*epsilon*/       {}
               | FormalsList        {}
;
FormalsList:   FormalsDecl       {}
               | FormalsDecl COMMA FormalsList        {}
;
FormalsDecl:   Type ID        {}
;
Statements:    Statement         {}
               | Statements Statement        {}
;
Statement:     
               /* Moved here If and While roles. solving 'Dangling Else' */
               IF LPAREN Exp RPAREN Statement       {
                  check_bool_exp(*$3);
               }
               | IF LPAREN Exp RPAREN Statement ELSE Statement       {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN Statement       {
                  check_bool_exp(*$3);
               }
               | WHILE LPAREN Exp RPAREN Statement ELSE Statement       {
                  check_bool_exp(*$3);
               }
               /* ^^^ Moved here If and While roles. solving 'Dangling Else' ^^^ */
               | LBRACE Marker2 Statements RBRACE         {
                  pop_tables();
                  pop_offsets();
               }
               | Type ID SC         {
                  insert(*$2, *$1, top_offsets());
                  top_offsets() += 1;
               }
               | Type ID ASSIGN Exp SC       {
                  insert(*$2, *$1, top_offsets());
                  top_offsets() += 1;
                  // cout << " offsets size is: " << offsets->size() << endl;
                  stack<int>* copy = new stack<int>(*offsets);
                  // cout << "[";
                  while(!copy->empty())
                  {
                     // cout << copy->top() << ",";
                     copy->pop(); 
                  }
                  // cout << "]" << endl;

                  /* Tables: */
                  // cout << "tables size is: " << tables->size() << endl;
                  stack<map<string,pair<string, int>>>* copyT = new stack<map<string,pair<string, int>>>(*tables);
                  // cout << "[";
                  while(!copyT->empty())
                  {
                     map<string,pair<string, int>> temp_map = copyT->top();
                     // cout << "TEMP MAP  size is: " << temp_map.size() << endl;
                     for(const auto& x : temp_map){
                        // cout << "Name: " << x.first << ", Type: " << x.second.first <<", Offset: "<< x.second.second <<  endl;
                     }
                     copyT->pop(); 
                  }
                  // cout << "]" << endl;

               }
               | ID ASSIGN Exp SC         {}
               | Call SC         {}
               | RETURN SC       {}
               | RETURN Exp SC         {}
               | BREAK SC        {}
               | CONTINUE SC        {}
;
Marker2:       /*epsilon*/        {
      t = make_table(&top_tables());
      push_tables(t);
      push_offsets(top_offsets());
}
;
Call:          ID LPAREN ExpList RPAREN         {
                  /* Rule #5 hw's PDF */
               
               }
               | ID LPAREN RPAREN         {
                  /* Rule #5 hw's PDF */
               }
;
ExpList:       Exp         {}
               | Exp COMMA ExpList        {}
;
Type:          INT            {
                  $$ = &TYPE_INT;
               }
               | BYTE         {
                  $$ = &TYPE_BYTE;
               }
               | BOOL         {
                  $$ = &TYPE_BOOL;
               }
;
Exp:           LPAREN Exp RPAREN       {}
               | Exp ADD_BINOP Exp         {
                     $$->type = binop(*$1, *$3);
                  }
               | Exp MUL_BINOP Exp         {
                     $$->type = binop(*$1, *$3);
                  }
               | ID        {
                  $$->type = &TYPE_BOOL;
                  cout << "EXP : ID is working" << endl;
                  cout <<  $$ << endl;
                  //TODO REMOVE
                  }
               | Call         {
                  $$->type = $1;
               }
               | NUM       {
                  cout << "EXP : NUM" << endl;
                  cout <<  $1 << endl;
                  cout <<  $$ << endl;
                  cout <<  TYPE_INT << endl;

                  $$->type = &TYPE_INT;
                  cout << "after type->" << endl;
                  $$->number = $1;
               }
               | NUM B       {
                  $$->number = $1;  
                  $$->type = &TYPE_BYTE;
               }
               | STRING       {
                  // String is an internal type
                  $$->str=$1;  
                  $$->type= &TYPE_STRING;
               }
               | TRUE         {
                  $$->bool_value=true;
                  $$->type = &TYPE_BOOL;
               }
               | FALSE        {
                  $$->bool_value=false;
                  $$->type = &TYPE_BOOL;
               }
               | NOT Exp         {}
               | Exp AND Exp        {
                  $$->type = log_eq(*$1, *$3);
               }
               | Exp OR Exp        {}
               | Exp EQUALITY_RELOP Exp        {
                  $$->type = relop(*$1, *$3);
               }
               | Exp RELATIONAL_RELOP Exp         {
                  $$->type = relop(*$1, *$3);
               }

;
%%

/* Rule #8 hw's PDF */
string* relop(Expression a, Expression b){
		if ((*(a.type) != TYPE_INT && *(a.type) != TYPE_BYTE)
      || (*(b.type) != TYPE_INT && *(b.type) != TYPE_BYTE)) {
			// Both must be numbers
			output::errorMismatch(yylineno);
			exit(0);
      }
      string* pointer_to_type;
      *pointer_to_type = TYPE_BOOL;
		return pointer_to_type;
}


/* Rule #9 hw's PDF */
string* log_eq(Expression a, Expression b){
		if (*(a.type) != TYPE_BOOL || *(b.type) != TYPE_BOOL) {
			// Both must be boolean
			output::errorMismatch(yylineno);
			exit(0);
      }
      string* pointer_to_type;
      *pointer_to_type = TYPE_BOOL;
		return pointer_to_type;
}

/* Rule #10 hw's PDF */
string* binop(Expression a, Expression b){
   if ((*(a.type) != TYPE_INT && *(a.type) != TYPE_INT) 
   || (*(b.type) != TYPE_BYTE && *(b.type) != TYPE_BYTE)) {
		// We allow: int&int, int&byte, byte&int or byte&byte
		output::errorMismatch(yylineno);
		exit(0);
	}
   string* pointer_to_type;
	if (*(a.type) == TYPE_INT || *(b.type) == TYPE_INT) {
      // If there is int, we will return int type
      *pointer_to_type = TYPE_INT;
		return pointer_to_type;
	} else {
      *pointer_to_type = TYPE_BYTE;
		return pointer_to_type;
	}
}

/* Rule #16 hw's PDF */
void check_bool_exp(Expression exp){
   cout << "check_bool_exp" << endl;
   if(exp.type == NULL){
      cout << "exp is NULL" << endl;
      return;
   }
   cout << exp.type << endl;
   cout << *(exp.type) << endl;
   if((*(exp.type)).compare(TYPE_BOOL)){
      output::errorMismatch(yylineno);
		exit(0);
   }
}




map<string,pair<string, int>>* make_table(map<string,pair<string, int>>* parent){
   // <Name, part<Type, Offset>>
   return new map<string,pair<string, int>>();
}
void pop_tables(){
   tables->pop();
}
void pop_offsets(){
   offsets->pop();
}
void push_tables(map<string,pair<string, int>>* table){
   tables->push(*table);
}
void push_offsets(int offset){
   offsets->push(offset);
}
map<string,pair<string, int>> &top_tables(){
   return tables->top();
}

int &top_offsets(){
   return offsets->top();
}

void insert(string name, string type,int offset){
   // cout << "INSIDE INSTERT FUNCTION: name: " << name << endl;
   // cout << "INSIDE INSTERT FUNCTION: type:" << type << endl;
   // cout << "INSIDE INSTERT FUNCTION:  :offset: " << offset << endl;



   (tables->top()).insert({
         name,
         pair<string ,int>(type,offset)
   });
}

void yyerror(const char*){
   output::errorSyn(yylineno); 
}

int main(){
   tables = new stack<map<string,pair<string, int>>>();
   offsets = new stack<int>();

   return yyparse();
}
